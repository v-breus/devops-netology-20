#### Задание 1

Перед выполнением задания ознакомьтесь с [документацией по администрированию MongoDB](https://docs.mongodb.com/manual/administration/).

Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и её нужно прервать.

Вы как инженер поддержки решили произвести данную операцию:

* напишите список операций, которые вы будете производить для остановки запроса пользователя
* предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB

**Ответ:**

1. Найти операцию

```
db.currentOp({ "active" : true, "secs_running" : { "$gt" : 3 }})
```

2. "Убить" ее по идентификатору

```
db.killOp(<opid>)
```

3. Для избежания такого в дальнейшем можно указать таймаут на операцию через директиву **$maxTimeMS**

#### Задание 2

Перед выполнением задания познакомьтесь с документацией по [Redis latency troobleshooting](https://redis.io/topics/latency).


Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. Причем отношение количества записанных key-value значений к количеству истёкших значений есть величина постоянная и увеличивается пропорционально количеству реплик сервиса.

При масштабировании сервиса до N реплик вы увидели, что:

* сначала рост отношения записанных значений к истекшим
* Redis блокирует операции записи

Как вы думаете, в чем может быть проблема?

**Ответ:**

Об этом говорили в лекции. Большое количество ключей истекает одновременно и сервис не успевает их удалять. Тут либо увеличивать кол-во операций `ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP` либо "разносить" ключи по времени, чтобы истекали не одномоментно. Можно также увеличить TTL у ключей, чтобы дать Redis'у больше времени для обработки. Еще вариант - дать использовать больше ресурсов CPU через директиву `active-expire-effort` (как я понял, она разрешает обрабатывать ключи не в один поток, а в несколько, если есть свободные ядра)

#### Задание 3

Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей, в таблицах базы, пользователи начали жаловаться на ошибки вида:

`InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
`
Как вы думаете, почему это начало происходить и как локализовать проблему?

Какие пути решения данной проблемы вы можете предложить?

**Ответ:**

Возможные причины:

1. Если сервер ДБ "удаленный" (НЕ localhost), то возможны сетевые проблемы. Для диагностики можно посмотреть на счетчик

`SHOW GLOBAL STATUS LIKE 'Aborted_connects'`. Если постепенно увеличивается - это оно.

2. Большой запрос, можно попробовать увеличить параметры `max_allowed_packet` и `read_timeout`

#### Задание 4

Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с большим объемом данных лучше, чем MySQL.

После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:

`postmaster invoked oom-killer`

Как вы думаете, что происходит?

Как бы вы решили данную проблему?

**Ответ:**

OOM приходит, когда на сервере заканчивается вся доступная RAM. Соответственно, пути решения:

1. Отключить OOM в принципе (не стоит так делать, ОС может "зависнуть намертво")
2. Директиивы PostgreSQL которые могут быть полезны:

`max_memory_usage` - определяет общее кол-во памяти, доступное Postgre

`shared_buffer` - сколько памяти из доступной используется для кеширования (рекомендуется 15-25% от общего объема RAM)

`work_mem` - количество памяти, используемое транзакциями до сброса на диск (рассчитывается по формуле RAM * 0.25 / max_connections)

`maintenance_work_mem` количество памяти, используемое транзакциями до сброса на диск, если сервер "в режиме обслуживания" (можно раза в 4 больше чем `work_mem`)

`effective_cache_size` - кол-во памяти под кеш (рекомендуется 50% от общего объема)

3. Докупить пару планок оперативки